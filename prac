package traversalGraph;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Stack;

public class trvs {
	public static void main(String []args)
	{
	Graph g=new Graph(6);
	vertex a=new vertex(1);
	vertex b=new vertex(2);
	vertex c=new vertex(4);
	vertex d=new vertex(3);
	vertex e=new vertex(5);
	vertex f=new vertex(6);
	vertex h=new vertex(7);
	g.addVertex(a);
	g.addVertex(b);
	g.addVertex(c);
	g.addVertex(d);
	g.addVertex(e);
	g.addVertex(f);
	g.addVertex(h);
	g.addEdgeDij(a,b,8);
	g.addEdgeDij(c,b,1);
	g.addEdgeDij(d,c,7);
	g.addEdgeDij(e,c,5);
	g.addEdgeDij(h,e,2);
	g.addEdgeDij(h,d,3);
	g.addEdgeDij(f,c,1);
	g.addEdgeDij(e,f,1);
//	ArrayList<vertex> vt=g.dfs(a);
//	for(vertex x:vt)
//	{
//		System.out.print(x.val+" , ");
//	}
//	System.out.println("");
//	for(vertex k:g.topSort(a))
//	{
//		System.out.print(k.val+" , ");
//	}
//	System.out.println("");
//	}
	for(vertex k:g.dijsktra(h))
	{
		System.out.print(k.val+" , ");
	}
	System.out.println("");
	}
}
class Graph
{
	public int numOfVertices;
	public ArrayList<vertex> vertexList;
	public ArrayList<LinkedList<vertex>> adjList;
	public ArrayList<LinkedList<Integer>> wtList;
	public Graph(int x) {
		numOfVertices=x;
		vertexList=new ArrayList<vertex>();
		adjList=new ArrayList<LinkedList<vertex>>();
		wtList=new ArrayList<LinkedList<Integer>>();
	}
	public void addVertex(vertex a)
	{
		vertexList.add(a);
		adjList.add(new LinkedList<vertex>());
		wtList.add(new LinkedList<Integer>());
	}
	public void addEdge(vertex src,vertex dest)//directed
	{
		adjList.get(src.val-1).add(dest);		
	}
	public void addEdgeDij(vertex src,vertex dest,int wt)//directed
	{
		adjList.get(src.val-1).add(dest);		
		wtList.get(src.val-1).add(wt);
	}
	public ArrayList<vertex> topSort(vertex root)
	{
		ArrayList<vertex> ap=new ArrayList<vertex>();
		int []indegree=new int[vertexList.size()];
		for(LinkedList<vertex> lt:adjList)
		{
			for(int i=0;i<lt.size();i++)
			{
				indegree[lt.get(i).val-1]+=1;
			}
		}
		int count=0;
		while(count<vertexList.size())
		{
			int minPos=0;
			boolean flag=false;
			for(int i=0;i<vertexList.size();i++)
			{
				if(indegree[i]==0)
				{
					ap.add(vertexList.get(i));
					indegree[i]=Integer.MAX_VALUE;
					count++;
					flag=true;
					break;
				}
				minPos=indegree[i]<indegree[minPos]?i:minPos;
			}
			if(!flag)
			{
				ap.add(vertexList.get(minPos));
				indegree[minPos]=Integer.MAX_VALUE;
				for(int j=0;j<adjList.size();j++)
				{
					if(adjList.get(j).contains(vertexList.get(minPos)))
						indegree[j]-=1;
				}
				count++;
			}
		}
		return ap;
	}
	public ArrayList<vertex> dijsktra(vertex root)
	{
		if(root==null)
			return new ArrayList<vertex>();
		ArrayList<vertex> ans=new ArrayList<vertex>();
		PriorityQueue<vertex> pq=new PriorityQueue<vertex>(new Comparator<vertex>() {

			@Override
			public int compare(vertex a, vertex b) {
				if(a.distanceFromSrc<=b.distanceFromSrc)
					return -1;
				else
					return 1;
			}			
		});
		root.distanceFromSrc=0;
		for(int i=0;i<vertexList.size();i++)
			pq.add(vertexList.get(i));
		while(ans.size()<vertexList.size())
		{
			vertex k=pq.poll();
			ans.add(k);
			for(int i=0;i<adjList.get(k.val-1).size();i++)
			{
				int f=wtList.get(k.val-1).get(i);
				if(vertexList.get(k.val-1).distanceFromSrc!=Integer.MAX_VALUE)
					vertexList.get(k.val-1).distanceFromSrc+=f;
				else
					vertexList.get(k.val-1).distanceFromSrc=f;
			}
			PriorityQueue<vertex> temp=new PriorityQueue<vertex>(new Comparator<vertex>() {

				@Override
				public int compare(vertex a, vertex b) {
					if(a.distanceFromSrc<=b.distanceFromSrc)
						return -1;
					else
						return 1;
				}			
			});
			while(!pq.isEmpty())
				temp.add(pq.poll());
			pq.clear();
			pq=new PriorityQueue<vertex>(temp);
		}
		return ans;
	}
	public ArrayList<vertex> bfs(vertex root)
	{
		ArrayList<vertex> ans=new ArrayList<vertex>();
		ArrayDeque<vertex> st=new ArrayDeque<>();
		st.offer(root);
		while(!st.isEmpty())
		{
			vertex k=st.poll();
			ans.add(k);
			k.visited=true;
			for(int i=0;i<adjList.get(k.val-1).size();i++)
			{
				if(!adjList.get(k.val-1).get(i).visited)
					st.offer(adjList.get(k.val-1).get(i));
			}
		}
		return ans;
	}
	public ArrayList<vertex> dfs(vertex root)
	{
		ArrayList<vertex> ans=new ArrayList<vertex>();
		ArrayDeque<vertex> st=new ArrayDeque<>();
		st.push(root);
		ans.add(root);
		while(!st.isEmpty())
		{
			vertex k=st.peek();
			k.visited=true;
			for(int i=0;i<adjList.get(k.val-1).size();i++)
			{
				if(!adjList.get(k.val-1).get(i).visited)
					{
						ans.add(adjList.get(k.val-1).get(i));
						st.push(adjList.get(k.val-1).get(i));
						break;
					}
			}
			if(k==st.peek())
				st.pop();
		}
		return ans;
	}
}
class vertex
{
	int val;
	boolean visited;
	int distanceFromSrc;//added for disjktra
	public vertex(int val) {
		this.val=val;
		visited=false;
		distanceFromSrc=Integer.MAX_VALUE;
	}
}
